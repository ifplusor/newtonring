#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import sys
import queue
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.patches import Circle
from mpl_toolkits.mplot3d import Axes3D
from skimage import feature, dtype_limits
from PIL import Image


# for calTransProb
vector = [[-1,-1], [0,-1], [1,-1], [1,0], [1,1], [0,1], [-1,1], [-1,0]]

def calTransProb(row, col, T, B, vec):
    """计算单个像素的转移概率"""
    height, width = T.shape
    index = row*width + col
    
    #deff between center and all around
    b = np.zeros(8)
    d = np.zeros(8)
    for k in vec:
        d[k] = T[row+vector[k][0]][col+vector[k][1]] - T[row][col] # center pixl 
        if d[k] > 0: # light
            b[k] = (256.0 - d[k]) / 6
        else: # dark
            b[k] = (256.0 + d[k]) / 3
    
    # probability for out
    bsum = np.sum(b)
    for k in vec:
        B[index][index + vector[k][0]*width + vector[k][1]] = b[k] / bsum


def calTransMatrix(T):
    """计算转移概率矩阵"""
    height, width = T.shape
    B = np.zeros((T.size, T.size))
    
    # calculate transfer matrix
    for j in range(1, width-1):
        for i in range(1, height-1):
            calTransProb(i, j, T, B, range(0,8))
    
    i = 0
    for j in range(1, width-1):
        calTransProb(i, j, T, B, range(1,6)) # top
    
    i = height-1
    for j in range(1, width-1):
        calTransProb(i, j, T, B, [5,6,7,0,1]) # bottom
    
    j = 0
    for i in range(1, height-1):
        calTransProb(i, j, T, B, range(3,8)) # left
    
    i = 0;        calTransProb(i, j, T, B, range(3,6)) # left-top
    i = height-1; calTransProb(i, j, T, B, range(5,8)) # left-bottom
    
    j = width-1
    for i in range(1, height-1):
        calTransProb(i, j, T, B, [7,0,1,2,3]) # right
    
    i = 0;        calTransProb(i, j, T, B, range(1,4)) # right-top
    i = height-1; calTransProb(i, j, T, B, [7,0,1])    # right-bottom
    
    return B


def mutipleTrans(M, B, shape):
    """矩阵乘法优化"""
    height, width = shape
    t = np.zeros_like(M)
    
    for j in range(1, width-1):
        for i in range(1, height-1):
            index = i*width+j
            for k in range(0,8):
                aindex = index + vector[k][0]*width + vector[k][1]
                t[index] += M[aindex] * B[aindex][index]
    
    i = 0
    for j in range(1, width-1):
        index = i*width+j
        for k in range(1,6): # top
            aindex = index + vector[k][0]*width + vector[k][1]
            t[index] += M[aindex] * B[aindex][index]
    
    i = height-1
    for j in range(1, width-1):
        index = i*width+j
        for k in [5,6,7,0,1]: # bottom
            aindex = index + vector[k][0]*width + vector[k][1]
            t[index] += M[aindex] * B[aindex][index]
    
    j = 0; 
    for i in range(1, height-1):
        index = i*width+j
        for k in range(3,8): # left
            aindex = index + vector[k][0]*width + vector[k][1]
            t[index] += M[aindex] * B[aindex][index]
    
    i = 0
    index = i*width+j
    for k in range(3,6): # left-top
        aindex = index + vector[k][0]*width + vector[k][1]
        t[index] += M[aindex] * B[aindex][index]
    
    i = height-1
    index = i*width+j
    for k in range(5,8): # left-bottom
        aindex = index + vector[k][0]*width + vector[k][1]
        t[index] += M[aindex] * B[aindex][index]
    
    j = width-1
    for i in range(1, height-1):
        index = i*width+j
        for k in [7,0,1,2,3]: # right
            aindex = index + vector[k][0]*width + vector[k][1]
            t[index] += M[aindex] * B[aindex][index]
    
    i = 0
    index = i*width+j
    for k in range(1,4): # right-top
        aindex = index + vector[k][0]*width + vector[k][1]
        t[index] += M[aindex] * B[aindex][index]
    
    i = height-1
    index = i*width+j
    for k in [7,0,1]:    # right-bottom
        aindex = index + vector[k][0]*width + vector[k][1]
        t[index] += M[aindex] * B[aindex][index]
    
    return t


def gaussianFilter(G):
    height, width = G.shape
    
    sigma = 0.4
    windowSize = 1 + 2 * np.int(np.ceil(3*sigma))
    center = windowSize // 2
    
    kernal2 = np.zeros((windowSize, windowSize))
    sum2 = 0.0
    
    for i in range(windowSize):
        for j in range(windowSize):
            disX = i - center
            disY = j - center
            kernal2[j][i] = np.exp(-0.5 * (disX**2 + disY**2) / (sigma**2) / (2*np.pi*(sigma**2)))
            sum2 += kernal2[j][i]
    
    for i in range(windowSize):
        for j in range(windowSize):
            kernal2[j][i] /= sum2
    
    T = np.zeros_like(G)
    for row in range(height):
        for col in range(width):
            filter = 0.0
            sum = 0.0
            for x in range(-center, center+1):
                for y in range(-center, center+1):
                    if 0<=(col+x)<width and 0<=(row+y)<height:
                        filter += double(G[row+y][col+x] * kernal2[y+center][x+center])
                        sum += kernal2[y+center][x+center]
            
            T[row][col] = filter/sum
    
    return T


def canny(G):
    """Canny 边缘检测（没有高斯滤波过程）"""
    height, width = G.shape
    
    # Step 1
    P = np.zeros_like(G) # gradient in x
    Q = np.zeros_like(G) # gradient in y
    M = np.zeros_like(G, dtype=np.int) # gradient
    Theta = np.zeros_like(G) # direction
    
    for row in range(height-1):
        for col in range(width-1):
            P[row][col] = (G[row][col+1]-G[row][col] + G[row+1][col+1]-G[row+1][col]) / 2.0
            Q[row][col] = (G[row][col]-G[row+1][col] + G[row][col+1]-G[row+1][col+1]) / 2.0
    
    for row in range(height):
        for col in range(width):
            M[row][col] = np.int(np.sqrt(P[row][col]**2 + Q[row][col]**2 + 0.5))
            Theta[row][col] = np.rad2deg(np.arctan2(Q[row][col], P[row][col]))
            if Theta[row][col] < 0:
                Theta[row][col] += 360
    
    # Step 2
    N = np.zeros_like(G, dtype=np.uint8)
    for col in range(1, width-1):
        for row in range(1, height-1):
            if M[row][col] == 0:
                N[row][col] = 0
            else:
                tmp1 = 0.0; tmp2 = 0.0
                if (90<=Theta[row][col]<135) or (270<=Theta[row][col]<315):
                    #  g1 g2
                    #     c
                    #     g3 g4
                    g1 = M[row-1][col-1]
                    g2 = M[row-1][col]
                    g3 = M[row+1][col]
                    g4 = M[row+1][col+1]
                    weight = np.fabs(P[row][col] / Q[row][col])
                elif (135<=Theta[row][col]<180) or (315<=Theta[row][col]<360):
                    #  g1
                    #  g2 c g3
                    #       g4
                    g1 = M[row-1][col-1]
                    g2 = M[row][col-1]
                    g3 = M[row][col+1]
                    g4 = M[row+1][col+1]
                    weight = np.fabs(Q[row][col] / P[row][col])
                elif (45<=Theta[row][col]<90) or (225<=Theta[row][col]<270):
                    #     g2 g1
                    #     c
                    #  g4 g3
                    g1 = M[row-1][col+1]
                    g2 = M[row-1][col]
                    g3 = M[row+1][col]
                    g4 = M[row+1][col-1]
                    weight = np.fabs(P[row][col] / Q[row][col])
                elif (0<=Theta[row][col]<45) or (180<=Theta[row][col]<225):
                    #       g1
                    #  g3 c g2
                    #  g4
                    g1 = M[row-1][col+1]
                    g2 = M[row][col+1]
                    g3 = M[row][col-1]
                    g4 = M[row+1][col-1]
                    weight = np.fabs(Q[row][col] / P[row][col])
                
                tmp1 = g1*weight + g2*(1-weight)
                tmp2 = g4*weight + g3*(1-weight)
                if M[row][col]>=tmp1 and M[row][col]>=tmp2:
                    N[row][col] = 128
                else:
                    N[row][col] = 0
    
    # Step 3
    ratHigh = 0.79
    ratLow = 0.5

    hist = np.zeros(500, dtype='i')
    for row in range(height):
        for col in range(width):
            if N[row][col] == 128:
                hist[M[row][col]] += 1
    
    edgeNum = 0
    maxMag = 0
    for i in range(len(hist)):
        if hist[i] > 0:
            maxMag = i
        edgeNum += 1
    
    highCount = np.int(ratHigh * edgeNum + 0.5)
    edgeNum = hist[1]
    k = 1
    while k<maxMag-1 and edgeNum<highCount:
        k += 1
        edgeNum += hist[k]
    
    thrHigh = k
    thrLow = np.int(thrHigh * ratLow + 0.5)
    # print("thrHigh is %f; thrLow is %f" % (thrHigh, thrLow))
    
    # Step 4
    for row in range(height):
        for col in range(width):
            if N[row][col]==128 and M[row][col]>=thrHigh:
                N[row][col] = 255
                traceEdge(row, col, thrLow, N, M)
    
    # Step 5
    for row in range(height):
        for col in range(width):
            if N[row][col] != 255:
                N[row][col] = 0
    
    return N


def traceEdge(row, col, thrLow, N, M):
    """连接边缘"""
    for k in range(8):
        y = row + vector[k][0]
        x = col + vector[k][1]
        if 0<=y<N.shape[0] and 0<=x<N.shape[1] and N[y][x]==128 and M[y][x]>=thrLow:
            N[y][x] = 255
            traceEdge(y, x, thrLow, N, M)

def findOnePoint(G):
    height, width = G.shape
    for row in range(height):
        for col in range(width):
            if G[row][col] == True:
                return (row, col)

def divideTips(G, thr):
    height, width = G.shape
    T = np.zeros_like(G, dtype=np.bool)
    findx = -1
    for row in range(height):
        fmax = thr-1
        for col in range(width):
            if G[row][col]>=thr:
                if G[row][col]>fmax:
                    fmax = G[row][col]
                    findx = col
            else:
                if fmax>=thr:
                    T[row][findx] = True
                    fmax = thr-1
        if fmax>=thr:
            T[row][findx] = True
    
    F = np.zeros_like(G, dtype=np.int)
    C = np.array(T, copy=True)
    tag = 1
    que = queue.Queue()
    point = findOnePoint(C)
    while point != None:
        que.put(point)
        C[point[0]][point[1]] = False
        F[point[0]][point[1]] = tag
        while not que.empty():
            y, x = que.get()
            for i in range(-10, 10):
                for j in range(-10, 10):
                    if 0<=(y+i)<height and 0<=(x+j)<width and C[y+i][x+j]==True:
                        que.put((y+i, x+j))
                        C[y+i][x+j] = False
                        F[y+i][x+j] = tag
        point = findOnePoint(C)
        tag += 1
    return F


def getTipList(G, tag):
    height, width = G.shape
    T = np.zeros_like(G, dtype=np.int)
    l = []
    for row in range(height):
        for col in range(width):
            if G[row][col] == tag:
                T[row][col] = tag
                l.append((float(row), float(col)))
    return l, T


def guessCenter(points):
    pa = points[0]
    pb = points[len(points)//2]
    pc = points[len(points)-1]
    t0x = (pa[0] + pb[0]) / 2.0
    t0y = (pa[1] + pb[1]) / 2.0
    a0 = (pa[0]-pb[0]) / (pa[1]-pb[1])
    b0 = a0 * t0x - t0y
    t1x = (pb[0] + pc[0]) / 2.0
    t1y = (pb[1] + pc[1]) / 2.0
    a1 = (pb[0]-pc[0]) / (pb[1]-pc[1])
    b1 = a1 * t1x - t1y
    x = (b1-b0) / (a0-a1)
    y = a0*x + b0
    return (x, y)


def fixCircle(points, center=None):
    a, b = (0.0, 0.0)
    if center != None:
        a, b = center
    step = 0.0001
    div = (len(points) * (len(points)-1)) / 2.0
    while True:
        da = 0.0
        db = 0.0
        cost = 0.0
        for i in range(len(points)-1):
            for j in range(i+1, len(points)):
                xi, yi = points[i]
                xj, yj = points[j]
                da += (xi**2 - xj**2 + yi**2 - yj**2 + 2*a*(xj-xi) + 2*b*(yj-yi)) * (xj-xi)
                db += (xi**2 - xj**2 + yi**2 - yj**2 + 2*a*(xj-xi) + 2*b*(yj-yi)) * (yj-yi)
        da /= div
        db /= div
        if np.fabs(da)<0.0001 and np.fabs(db)<0.0001:
            break
        a -= da * step
        b -= db * step
    R = 0.0
    for point in points:
        R += (a-point[0])**2 + (b-point[1])**2
    R /= len(points)
    R = np.sqrt(R)
    return (a, b), R


origin = Image.open("huan128.jpg")
A = origin.convert("L") # convert origin image to grey-scale map

T = np.array(A, dtype='d')

B = calTransMatrix(T)
M = np.array([1.0] * T.size)

g = 100
if len(sys.argv) > 1:
    g = int(sys.argv[1])
print("g is %d" % (g))

for k in range(g):
    M = mutipleTrans(M, B, T.shape)

tmax = np.max(M)
tmin = np.min(M)
print("max is %f; min is %f" % (tmax, tmin))
lowThr = np.percentile(M, 70)
print("low thr is %f" % lowThr)

M = M.reshape(T.shape)

edgeM = feature.canny(M, low_threshold=lowThr)
edgeO = feature.canny(T)

S = divideTips(M, lowThr)
L, S1 = getTipList(S, 2)
center = guessCenter(L)
print("the center from guess is (%f, %f)" % (center[0], center[1]))
center, R = fixCircle(L, center)
print("center is (%f, %f)\nradius is %f" % (center[0], center[1], R))

# show image
fig1 = plt.figure()

plt.subplot(231)
plt.title('origin image')
plt.imshow(origin)

plt.subplot(232)
plt.title('grey-scale map')
plt.imshow(A)

plt.subplot(233)
plt.title('origin edge')
plt.imshow(edgeO)

plt.subplot(235)
plt.title('random walk')
plt.imshow(M)

plt.subplot(236)
plt.title('random edge')
plt.imshow(edgeM)

ax = fig1.add_subplot(234, projection='3d')
ax.set_title('3D graph')
Y = np.arange(M.shape[0])
X = np.arange(M.shape[1])
X, Y = np.meshgrid(X, Y)
ax.plot_surface(X, Y, M, rstride=2, cstride=2, cmap=cm.YlGnBu_r, linewidth=0)


fig2 = plt.figure()

plt.subplot(221)
plt.hist(M)

plt.subplot(222)
plt.imshow(S)

plt.subplot(223)
plt.imshow(S1)

ax = fig2.add_subplot(224)
cirl = Circle(center, radius=R, alpha=0.5)
ax.add_patch(cirl)
ax.plot(center[0], center[1], 'r.')
ax.plot([p[0] for p in L], [p[1] for p in L], 'r,')
plt.axis('scaled')

plt.show()

